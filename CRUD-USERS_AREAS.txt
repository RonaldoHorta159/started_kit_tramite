Resumen ejecutivo

Implementamos un CRUD completo de usuarios con paginaciÃ³n, orden y filtros server-side usando Laravel + Inertia + Vue 3 + TanStack Table.

Integramos asignaciÃ³n de primary_area_id (relaciÃ³n users.primary_area_id â†’ areas.id), con Select y validaciÃ³n.

Estandarizamos modales de Crear / Editar / Eliminar con UX consistente, notificaciones y refresco automÃ¡tico del datatable despuÃ©s de cada acciÃ³n.

Arquitectura y flujo

Frontend

DataTable (TanStack): columnas, selecciÃ³n por fila, menÃº de acciones (Editar/Eliminar).

Toolbar: bÃºsqueda global (q), filtros mÃºltiples por Estado y Rol, filtro select por Ãrea y menÃº para mostrar/ocultar columnas.

Pagination: controlada desde el estado de TanStack (sincronizada con el backend).

Modales

UserFormModal.vue: crear/editar (sin watch, hidrataciÃ³n por lifecycle + :key, v-model:open).

DeleteUserAlert.vue: confirmaciÃ³n de borrado (useForm.delete), cierra/avisa y refresca lista.

Estado y orquestaciÃ³n

useUsersTable.js: composable que conecta TanStack con Inertia para paginaciÃ³n/orden/filtrado manual (server-side), reactivo a props.data/props.filter mediante refs (toRef). Expone refresh() para recargar sÃ³lo data y filter.

Backend (Laravel)

Rutas: GET/POST/PUT/DELETE /users con nombres users.index/store/update/destroy.

UserController

index: whitelist de orden (dni, nombres, email, rol, estado, created_at), filtros (q, estado[], rol[], area_id), with('primaryArea'), paginate()->appends(). Devuelve data, filter y opciones (areasOptions, rolesOptions, estadosOptions).

store / update: usan FormRequests (validaciÃ³n, hash de password, update opcional del password).

destroy: borra y redirige a users.index preservando query params (para mantener estado de la tabla).

Base de datos

users: campos (dni, nombres, apellidos, email, celular, password, foto_path, primary_area_id, rol, estado).

areas: catÃ¡logo.

FK users.primary_area_id â†’ areas.id con Ã­ndice y nullOnDelete.

RelaciÃ³n Eloquent User::primaryArea().

Decisiones clave y correcciones que hicimos

Server-side datatable real

Activamos manualPagination, manualSorting, manualFiltering y conectamos cambios de UI con router.get('/users', {...}).

En useUsersTable hicimos el estado reactivo a props (ya no es â€œfotoâ€ estÃ¡tica).

Filtros alineados front/back

Columnas â€œfantasmaâ€ (q, area_id) para enviar filtros sin renderizar columnas.

Mapeo Estado y Rol con valores canÃ³nicos (y soporte a {value,label}).

Orden robusto y seguro

Whitelist de campos de orden (dni incluido).

â€œÃreaâ€ sin orden por ahora (evita mismatch con backend).

Modales consistentes (sin watch)

UserFormModal: v-model:open, hidrataciÃ³n sin watchers usando onMounted/onUpdated + clave :key para remonte visual por registro (crÃ­tico para <Select>).

AlineaciÃ³n de eventos: el hijo emite update:open; el padre usa v-model:open. Eliminamos el desajuste modelValue.

Autocompletar: carga limpia de form al abrir y al cambiar de registro.

Eliminar que realmente refresca

DeleteUserAlert: useForm.delete + toast + cerrar modal + reload/visit a /users con query params.

destroy() redirige a users.index preservando el query.

Crear/Editar que refresca

onSuccess: cerrar modal, notificar, y visitar /users${window.location.search} con preserveState:false.

Padre tambiÃ©n puede llamar refresh() del composable (recarga parcial only: ['data','filter']).

Estructura de archivos

resources/js/pages/users/index.vue: pÃ¡gina Inertia que pasa data/filter/options a la tabla.

components/DataTable/index.vue: orquestador (tabla, toolbar, paginaciÃ³n, modales).

components/DataTable/useUsersTable.js: composable TanStack â†” Inertia (server-side).

components/DataTable/Columns.js: definiciÃ³n de columnas y acciones.

components/DataTable/Toolbar.vue: filtros y buscador.

components/DataTable/Pagination.vue: control de pÃ¡gina y page size.

components/DataTable/UserFormModal.vue: crear/editar (sin watchers).

components/DataTable/DeleteUserAlert.vue: confirmaciÃ³n de eliminaciÃ³n.

QuÃ© quedÃ³ funcionando (end-to-end)

Listado de usuarios con paginaciÃ³n, orden por columnas, bÃºsqueda global, filtros por estado/rol, y filtro por Ã¡rea.

Crear usuario â†’ validaciÃ³n, toast, cierre del modal y lista actualizada.

Editar usuario â†’ autocompletado correcto (incluyendo selects), validaciÃ³n, toast, cierre del modal y lista actualizada.

Eliminar usuario â†’ confirmaciÃ³n, toast, datos actualizados en la tabla.

AsignaciÃ³n y visualizaciÃ³n de Ã¡rea primaria (join vÃ­a with('primaryArea') y Select por primary_area_id).

Ideas de siguiente iteraciÃ³n (si quieres)

Hacer ordenable la columna Ãrea (leftJoin('areas', ...) y orderBy('areas.nombre')).

Acciones masivas (activar/desactivar, eliminar en lote).

Exportar CSV con filtros aplicados.

Policies (Gate/Policy) para permisos por rol.

Optimizar UI: loaders en celdas, mensajes vacÃ­os contextualizados, atajos de teclado.

Si quieres, te preparo un checklist de tests manuales para validar cada flujo (crear, editar, eliminar, paginar, filtrar) antes de cerrarlo y moverlo a producciÃ³n.

âœ… PreparaciÃ³n

 Base limpia / seed

Paso: aplica migraciones y siembra 10â€“50 usuarios y 5â€“10 Ã¡reas.

Resultado: hay suficientes datos para probar paginaciÃ³n, filtros y orden.

 SesiÃ³n iniciada

Paso: inicia sesiÃ³n con un usuario con permisos para CRUD.

Resultado: acceso a /users sin errores.

ğŸ§­ Carga inicial / Render

 Render inicial

Paso: abre /users.

Resultado: tabla visible, columnas correctas, toolbar y paginaciÃ³n presentes; sin errores en consola.

 Cero resultados

Paso: filtra algo imposible (ej. q=zzzzzzzz).

Resultado: mensaje â€œNo results.â€ y sin errores.

ğŸ” PaginaciÃ³n (server-side)

 Cambiar pÃ¡gina

Paso: avanza a la pÃ¡gina 2.

Resultado: tabla muestra nuevos registros; la URL refleja ?page=2.

 Cambiar â€œRows per pageâ€

Paso: cambia a 50.

Resultado: se ven 50 filas (o menos si no alcanza); URL con per_page=50.

 Botones de extremos

Paso: ir a la primera y Ãºltima pÃ¡gina.

Resultado: botones habilitan/deshabilitan correctamente.

â†•ï¸ Orden (server-side)

 Orden por DNI

Paso: clic en cabecera DNI (asc/desc).

Resultado: filas ordenadas; URL con sort_field=dni&sort_direction=asc|desc.

 Orden por Nombres / Email / Rol / Estado

Paso: alterna orden en cada columna.

Resultado: tabla cambia y la URL refleja el orden.

 Ãrea (no ordenable)

Paso: intenta ordenar Ãrea.

Resultado: no cambia el orden (desactivado â€“ sin errores).

ğŸ” Filtros / BÃºsqueda

 BÃºsqueda global (q)

Paso: escribe parte de un DNI o nombre; enter/blur.

Resultado: sÃ³lo aparecen coincidencias; URL incluye q=....

 Filtro Estado (multi)

Paso: marca â€œActivoâ€; luego â€œInactivoâ€; luego ambos.

Resultado: tabla filtra correctamente; URL incluye estado[]=....

 Filtro Rol (multi)

Paso: marca uno o mÃ¡s roles; limpiar filtro.

Resultado: tabla actualiza y se limpian filtros.

 Filtro Ãrea (select)

Paso: elige un Ã¡rea; luego â€œTodasâ€.

Resultado: tabla filtra por area_id; â€œTodasâ€ quita area_id.

â• Crear usuario

 Abrir modal Crear

Paso: clic â€œCrear nuevoâ€.

Resultado: modal abierto, campos en blanco (estado = â€œActivoâ€).

 ValidaciÃ³n client/server mÃ­nima

Paso: envÃ­a vacÃ­o; luego DNI < 8; email invÃ¡lido; repetir email/dni existente.

Resultado: muestra errores de validaciÃ³n y no crea registro.

 Crear OK

Paso: completa todos los campos vÃ¡lidos (password requerido); asigna Ãrea; elige Rol y Estado.

Resultado: toast de Ã©xito, modal se cierra, tabla actualizada mostrando el nuevo usuario (segÃºn filtros/pÃ¡gina), sin errores en consola.

âœï¸ Editar usuario

 Autocompletar

Paso: en el menÃº de una fila, â€œEditarâ€.

Resultado: modal con todos los campos prellenos (incluyendo Ãrea/ Rol/ Estado).

 Password opcional

Paso: no ingreses password y guarda.

Resultado: se actualizan otros campos y no cambia la contraseÃ±a.

 Cambiar Ãrea / Rol / Estado

Paso: modifica esos selects y guarda.

Resultado: persiste en BD y la tabla refleja los nuevos valores.

 URL/estado

Paso: tras guardar, revisa URL y tabla.

Resultado: se mantiene el query (filtros/pÃ¡gina); tabla refrescada.

ğŸ—‘ï¸ Eliminar usuario

 ConfirmaciÃ³n

Paso: â€œEliminarâ€ en una fila â†’ confirmar.

Resultado: toast de Ã©xito, modal se cierra, la fila desaparece; no aparece en BD.

 Cancelar

Paso: abrir eliminar â†’ â€œCancelarâ€.

Resultado: no cambia nada.

ğŸ”„ RehidrataciÃ³n / Estado

 preserveState

Paso: cambia filtros y pÃ¡gina; elimina o edita un registro.

Resultado: tras operaciÃ³n, se conservan filtros/pÃ¡gina y se ve la tabla actualizada.

 Back/Forward del navegador

Paso: usa atrÃ¡s/adelante con filtros activos.

Resultado: estado de la tabla coincide con la URL.

ğŸ” Validaciones / Reglas (FormRequests)

 StoreUserRequest

Paso: prueba reglas (dni 8 dÃ­gitos Ãºnico, email Ãºnico, password confirmed, primary_area_id existente o null, rol/estado vÃ¡lidos).

Resultado: errores claros y localizados; no se crea registro invÃ¡lido.

 UpdateUserRequest

Paso: email/dni duplicados (de otro usuario), password vacÃ­o (debe ignorarse), primary_area_id invÃ¡lido.

Resultado: sÃ³lo actualiza si es vÃ¡lido; password queda igual si no se envÃ­a.

ğŸ§± Integridad de datos

 FK primary_area_id

Paso: cambia el Ã¡rea; elimina un Ã¡rea usada (si la FK permite nullOnDelete).

Resultado: si eliminas el Ã¡rea, primary_area_id se vuelve NULL (segÃºn FK); no hay huÃ©rfanos invÃ¡lidos.

 RelaciÃ³n primaryArea

Paso: revisa que en el listado aparezca el nombre del Ã¡rea (con with('primaryArea')).

Resultado: se ve el nombre correcto o â€œâ€”â€ si no hay Ã¡rea.

ğŸ§© UI/UX

 Modales

Paso: abrir/cerrar con botÃ³n, fuera del modal y tecla Esc.

Resultado: sin errores; foco atrapado correctamente.

 Selects (Ãrea/Rol/Estado)

Paso: abrir/cerrar; seleccionar; ver etiqueta correcta.

Resultado: valor persistente y consistente tras guardar.

 Toasts

Paso: crear/editar/eliminar.

Resultado: mensajes de Ã©xito; mensajes de error en validaciones.

âš™ï¸ Rendimiento

 Respuestas rÃ¡pidas

Paso: cambiar rÃ¡pidamente orden/filtros/pÃ¡gina.

Resultado: navegaciÃ³n estable (sin â€œparpadeosâ€, sin errores 429).

 Carga de 100+ filas

Paso: per_page=100.

Resultado: render fluido; sin cuelgues.

â™¿ Accesibilidad mÃ­nima

 Foco

Paso: abre modal; tabula por los campos.

Resultado: orden de foco lÃ³gico; cierre con Esc.

 Texto alternativo

Paso: avatares con alt (o fallback de iniciales).

Resultado: correcto.

ğŸ“Œ Logging y Network

 Consola limpia

Paso: recorre todas las acciones.

Resultado: sin Unhandled error ni warnings.

 Network (DevTools)

Paso: revisa las solicitudes GET/POST/PUT/DELETE.

Resultado: cÃ³digos 2xx; los redirects tras DELETE/PUT/POST terminan en GET /users?....

ğŸ§ª Casos borde

 Campos largos (nombres/apellidos con ~100 chars).

 Sin Ã¡rea (primary_area_id = null).

 Emails con mayÃºsculas (debe normalizarse / validarse).

 Espacios en DNI/email (recortes esperados).

 Roles/Estados con opciones {value,label} (valor canÃ³nico al guardar).

âœ”ï¸ Criterio de aceptaciÃ³n final

El datatable refleja cualquier alta/baja/ediciÃ³n sin recargar manualmente la pÃ¡gina y conservando filtros/paginaciÃ³n.

Los modales autocompletan y se cierran sin errores.

La URL siempre representa el estado actual (page, per_page, sort, filters).

La BD mantiene integridad (FK) y reglas de validaciÃ³n.

Si quieres, te preparo un script de seeding con datos realistas (nombres/Ã¡reas) para repetir estas pruebas rÃ¡pido.